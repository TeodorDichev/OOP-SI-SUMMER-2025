# Теория:
## Двоични файлове

Предишният път разгледахме как работят текстовите файлове. При тях трябва да забележим, че винаги преди да запишем нещо, то първо се превръща в символен низ и тогава се записва.

## Пример:
Ако имаме променлива `short x = 2`, в паметта ще изглежда по следния начин:  
`00000010 00000000`

Ако запишем `x` във файл по следния начин:
```cpp
ofs << x;
```
Това число ще се преобразува в символи и тогава ще се запише във файла. 

Съдържанието на файла ще е **един байт** - ASCII стойността на символа `'2'`, което е числото `50`. Дефакто се получава, че стойността на файла ще бъде байтът, 
който изглежда по следния начин:  
`00110010`

След време, когато решим да прочетем числото от файла ще се осъществи обратното преобразувание: от символ към число.

Това преобразуване от число към стринг при писане и от стринг към число при четене е още една операция, която допълнително забавя целия процес.

Можем да запишем променливата **точно така както е представена в паметта**.

## Двоичен файл
- Файл, който е готов за зареждане в паметта.

### Разлика между текстов и двоичен файл:
- **Текстов файл**: лесен за нас, труден за програмата
- **Двоичен файл**: труден за нас, лесен за програмата

## Можем ли да кажем дали един файл е двоичен или текстов?
Отговорът е **не**, въпрос на интерпретация е.

---

## Работа с двоични файлове

### Функции `read` и `write`

```cpp
write(const char* memblock, size_t numOfBytes);
read(char* memblock, size_t numOfBytes);
```

- `memblock` - указател към някаква памет (байтове)
- `numOfBytes` - колко байта да се запишат или прочетат

Извикват се като член-функции:
```cpp
ofs.write(...);
ifs.read(...);
```

**Важно:** Изисква се `char*` или `const char*`, ако искаме да запишем друг тип, то трябва да го **кастнем**.

---

## Примери

### Отваряне на файлове в двоичен режим
Трябва да отворим потока в **двоичен режим**!

```cpp
std::ofstream ofs("bin.dat", std::ios::binary);
std::ifstream ifs("bin1.dat", std::ios::binary);
```

### Проверка дали файлът е отворен
```cpp
if (!ofs.is_open()) {
    std::cout << "Грешка при отваряне на файла за запис!" << std::endl;
    return;
}

if (!ifs.is_open()) {
    std::cout << "Грешка при отваряне на файла за четене!" << std::endl;
    return;
}
```

---

### Запазване и прочитане на `int` в двоичен файл
```cpp
int x = 123;

ofs.write((const char*)&x, sizeof(int));
ifs.read((char*)&x, sizeof(int));
```

---

### Запазване и прочитане на масив
Понеже елементите на масива са подредени последователно в паметта, можем да го прочетем или запишем с **едно извикване** на `read` или `write`:
```cpp
constexpr size_t SIZE = 5;

int arr[SIZE] = {1, 2, 3, 4, 5};

ofs.write((const char*)arr, SIZE * sizeof(int));
ifs.read((char*)arr, SIZE * sizeof(int));
```

**Важно:** Когато запишем масив от числа по този начин, при отваряне на файла в текстов редактор **няма да виждаме тези числа**, а **символната им репрезентация**.

---

### Запазване и прочитане на структура
Понеже полетата на структурата са **последователни в паметта**, отново **нямаме проблем**:
```cpp
struct Point {
    int x, y;
};

Point p = {1, 2};

ofs.write((const char*)&p, sizeof(Point));
ifs.read((char*)&p, sizeof(Point));
```

---

### Запазване и прочитане на масив от структури
```cpp
constexpr size_t SIZE = 3;

Point arr[SIZE] = {{1, 2}, {4, 5}, {8, 3}};

ofs.write((const char*)arr, SIZE * sizeof(Point));
ifs.read((char*)arr, SIZE * sizeof(Point));
```

# Теория `std::stringstream`:

### Какво е `std::stringstream`?  
`std::stringstream` е поток, който ни позволява да работим с низове, така както бихме работили с файлове или стандартния вход/изход.  

### Защо да използваме `std::stringstream`?  
- Позволява **форматирано извеждане** и **четене** от низове.  
- Улеснява **преобразуването** на различни типове данни в текстов формат и обратно.  

---

## Основни операции с `std::stringstream`

### Записване и четене от `stringstream`  
За да запишем стойности в `std::stringstream`, използваме оператора `<<`, подобно на `std::cout`.  
За да прочетем стойности от `std::stringstream`, използваме оператора `>>`, подобно на `std::cin`.  

#### Пример:  
```cpp
#include <iostream>
#include <sstream>

int main() {
	std::stringstream ss;

	// Записване в stringstream
	ss << "Число: " << 42 << ", Дробно: " << 3.14;

	// Извеждане на съдържанието
	std::cout << "Съдържание на ss: " << ss.str() << std::endl;

	// Подаване на нова стойност за четене
	ss.str("123 45.67 пример");

	int x;
	double y;
	char word[1024];

	// Четене от stringstream
	ss >> x >> y >> word;

	std::cout << "x = " << x << ", y = " << y << ", word = " << word << std::endl;

	return 0;
}
```

#### Изчистване на stringstream:

```c++
ss.str(""); // Изчиства съдържанието 
ss.clear(); // Нулира флаговете за грешки
```

#### Друг начин за създаване на stringstream:

```c++
#include <iostream>
#include <sstream>

int main() {
	std::stringstream ss("123 45.67 example");
	// Подаване на низ в конструктора. Потокът ще работи с подадения стринг.

	int x;
	double y;
	char word[1024];
	ss >> x >> y;
	ss.getline(word, 1024);
    
	std::cout << "x = " << x << ", y = " << y << ", word = " << word << std::endl;
	return 0;
}

```
