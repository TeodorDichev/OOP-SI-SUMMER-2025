## Йерархия на потоците

```plaintext
             ios
         /        \
     istream    ostream
      /    \     /     \
ifstream   iostream    ofstream
            /     \
       fstream   stringstream
```

Всички потоци за изход (`ofstream`) имат **put указател**. Всички потоци за вход (`ifstream`) имат **get указател**. Те указват текущата позиция, от която можем да пишем или четем.

## Функции за манипулация на позицията на get и put указателите

- `.tellg()` - връща позицията на get указателя (за `ifstream`)
- `.tellp()` - връща позицията на put указателя (за `ofstream`)
- `.seekg(offset, position)` - поставя get указателя на offset позиции спрямо position
- `.seekp(offset, position)` - поставя put указателя на offset позиции спрямо position

position по default е `std::ios::beg`

- `std::ios::beg` - начало на файла
- `std::ios::end` - край на файла
- `std::ios::cur` - текуща позиция

## Форматиран вход и изход

- **Форматиран вход:** `<Поток за вход> >> <обект>`
- **Форматиран изход:** `<Поток за изход> << <обект>`

Операторите `<<` и `>>`:

- Пропускат празни места и редове
- Връщат референция към потока и могат да се **chain-ват**

Пример:

```cpp
cout << 4 << ' ' << "test";
```

- `cout` е обект от тип `ostream`, затова можем да използваме `<<`
- `cin` е обект от тип `istream`, затова можем да използваме `>>`

## Неформатиран вход

- `.get()` - Връща ASCII стойността на символа, който е на позицията на get указателя и премества get указателя с една позиция.
- `.peek()` - Връща ASCII стойността на символа, който е на позицията на get указателя и НЕ премества get указателя.
- `.ignore()` - премества get указателя с една позиция
- `.ignore(positionsCount)` - премества get указателя с positionsCount позиции
- `.ignore(positionsCount, delim)` - пропуска до positionsCount символа във входния поток или до срещането на символа delim, което настъпи първо. Ако delim бъде намерен, той също се пропуска.
- `.get(char* buffer, int BUFFER_SIZE, char delim)` -> Прочита съдържанието на файла в буфера, докато не
срещне разделител или докато не се запълни буферът. В буфера, на мястото на разделителя слага терминираща нула. Разделителят по подразбиране е краят на файла. Премества
get указателя НА ПОЗИЦИЯТА, НА КОЯТО Е БИЛ РАЗДЕЛИТЕЛЯТ!
- `.getline(char* buffer, int BUFFER_SIZE, char delim)` -> Прочита съдържанието на файла в буфера, докато не
срещне разделител или докато не се запълни буферът. В буфера, на мястото на разделителя
слага терминираща нула. Разделителят по подразбиране е '\n'. Премества get указателя на ПОЗИЦИЯТА, СЛЕД РАЗДЕЛИТЕЛЯ!


## Неформатиран изход

`.put(char ch)` -> Поставя един символ на позицията, на която е put указателя и премества put указателя с една позиция.

Когато пишем във файл, информацията първо отива в специален buffer и след някакво време се записва в файла. Това се прави от езика с цел оптимизация.
Можем ние експлицитно да кажем на буфера да се запише чрез функцията .flush()

`std::endl` -> Записва символа за нов ред '\n' и извиква функцията .flush() на потока

`.close()` -> Затваря поток и преди това извиква flush(). При унищожаване на обекта автоматично се извиква close()


## Режими на работа

Когато създаваме нов поток можем да укажем и режим на работа. Това е цяло число, на което различните битове означават различни неща. За това различните режими на работа
са изнесени като константи, където всеки един режим е различна степен на двойката. Това ни дава възможност лесно да комбинираме няколко режима на работа като използваме побитово или (|).

| Бит | Режим                 | Описание                                       |
| --- | --------------------- | ---------------------------------------------- |
| 1   | `std::ios::in`        | Отваря за четене                               |
| 2   | `std::ios::out`       | Отваря за писане                               |
| 4   | `std::ios::ate`       | `put` указателят е в края, но може да се мести |
| 8   | `std::ios::app`       | `put` указателят е в края, не може да се мести |
| 16  | `std::ios::trunc`     | Изтрива съдържанието на файла, ако съществува  |
| 32  | `std::ios::binary`    | Отваря файла в двоичен формат                  |
| 64  | `std::ios::nocreate`  | Отваря само ако файлът **съществува**          |
| 128 | `std::ios::noreplace` | Отваря само ако файлът **не съществува**       |

За ofstream по default са включени std::ios::out и std::ios::trunc.
За ifstream по default е включен std::ios::in

### Пример за комбиниране на режими:

```cpp
std::ofstream ofs("file.txt", std::ios::out | std::ios::app);
```

## Състояние на потока

- `.bad()` -> Връща дали bad битът е вдигнат. Дали има загуба на информация (потокът е в невалидно състояние)
- `.fail()` -> Връща дали fail или bad битът е вдигнат. Дали последната операция е невалидна
- `.eof()` -> Връща дали eof битът е вдигнат. Дали краят на файла е достигнат
- `.good()` -> Връща дали и трите по-горни бита са нула. Когато всичко е успешно
- `.clear()` -> Изчиства състоянието на потока


