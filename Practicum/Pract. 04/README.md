# Теория:

# Член-функции, конструктори, деструктори

## Член-функция

Член-функция - функция в тялото на структура/клас. Работи директно с член данните на обекта и се извиква от него. Преобразува се от компилатора до външна функция, но с още един параметър, указател към обекта, от който се извиква.

```cpp
struct A
{
	void g();  // Преобразува се до void g(A* const this)
	void h() const; // Преобразува се до void h(const A* const this)
};
```

## Константна член-функция

Това е член-функция, която няма да променя член данните на обекта. Обозначава се с ключовата дума `const`. В константни функции могат да се извикват само константни функции!!

### !!Const correctness!!

Винаги, когато пишем функция, която няма да променя член-данните, задължително я правим константна!

```cpp
struct A
{
	void f() const;
	void g();
	void t() const;
};
```

**f() може да извиква:** `t()`\
**g() може да извиква:** `f()`, `t()`\
**t() може да извиква:** `f()`

```cpp
struct A
{
	void f();
	void f() const;
};
```

- Ако се извиква от `const A&`/`const A*`/`const A` → ще се извика константната функция
- Ако се извика от `A&`/`A*`/`A` → ще се извика неконстантната функция

## Конструктор

Член-функция, която се извиква при създаване на обекта. Има същото име като структурата/класа. Няма тип. Може да имаме много конструктори. Конструктор без параметри се нарича **default-ен конструктор**. Ако в структурата не е разписан нито един конструктор, то компилаторът автоматично създава default-ен конструктор.

```cpp
A a; // извиква се default-ен конструктор
A obj(); // това е функция, която връща А
```

```cpp
struct A
{
	B b;
	C c;
};
```

```cpp
A a; // извикват се дефолтните конструктори в реда, в който са подредени:
// B(), C(), A()
```

За да можем да създадем масив, трябва да има **дефолтен конструктор**. Ако няма такъв и се опитаме да създадем масив, няма да се компилира!

## Конвертиращ конструктор

Конструктор с точно **ЕДИН** аргумент.

```cpp
struct A
{
	A(int x)
	{
	}
};
```

```cpp
void f(A obj)
{
}
```

Можем да извикаме `f` по следния начин:

```cpp
f(12); // Създава се временен обект А
```

С ключовата думa `explicit` можем да **забраним** на конструктора да е конвертиращ.

```cpp
struct A
{
	explicit A(int x)
	{
	}
};
```

## Деструктор

Член-функция, която отговаря за изчистването на външните ресурси. Може да има **точно ЕДИН** деструктор. Извиква се при унищожаване на обекта. Има същото име като структурата/класа, но с `~` отпред. Ако не се разпише, компилаторът генерира такъв.

```cpp
struct A
{
	B b;
	C c;

	~A()
	{
	}
};
```

**Извикват се деструкторите в обратен ред:**

```cpp
~A(), ~C(), ~B()
```


**Задача 1:** Какво ще отпечата кода? Има ли грешки в него?

```c++
#include <iostream>

struct A {
	char* arr;

	A() {
    		arr = new char[10];
    		std::cout << "A()" << std::endl;
	}

	~A() {
    		std::cout << "~A()" << std::endl;
	}
};

int main() {
	A arr[2];
	A* ptr = new A[3];
}
```

**Задача 2:** Какво ще се отпечата?

```c++
#include <iostream>

struct C {
	double d;

	C() {
    		std::cout << "C()" << std::endl;
	}

	~C() {
    		std::cout << "~C()" << std::endl;
	}
};

struct B {
	int b;
	char c;

	B() {
    		std::cout << "B()" << std::endl;
	}

	~B() {
    		std::cout << "~B()" << std::endl;
	}
};

struct A {
	B b;
	C c;

	A()  {
    		std::cout << "A()" << std::endl;
	}

	~A() {
    		std::cout << "~A()" << std::endl;
	}
};

int main() {
	A arr[2];
	A* ptr = new A[1];

	delete[] ptr;
}
```

**Задача 3:** Какво ще се отпечата?

```c++
#include <iostream>

struct C {
	double d;

	C(double d) {
    		this->d = d;
    		std::cout << "C(double d)" << std::endl;
	}

	~C() {
    		std::cout << "~C()" << std::endl;
	}
};


int main() {
	C arr[2];
	C* ptr = new C[1];

	delete[] ptr;
}
```

**Задача 4:** Какво ще се отпечата?

```c++
#include <iostream>

struct M {
	int m;

	M() {
    		m = 6;
    		std::cout << "M()" << std::endl;
	}

	~M() {
    		std::cout << "~M()" << std::endl;
	}
};

struct C {
	double d;
	M member;

	C() {
    		std::cout << "C()" << std::endl;
	}

	C(double d) {
    		this->d = d;
    		member.m = 10;
    		std::cout << "C(double d)" << std::endl;
	}

	~C() {
    	std::cout << "~C()" << std::endl;
	}
};


int main() {
	C c = 5.2;
	C* ptr = new C[3];

	std::cout << c.member.m << std::endl;

	std::cout << ptr[0].member.m << std::endl;

	delete[] ptr;
}
```

**Задача 5:** Какво ще се отпечата?

```c++
#include <iostream>

struct C {
	double d;

	C() {
    	std::cout << "C()" << std::endl;
	}

	C(double d) {
    	this->d = d;
    	std::cout << "C(double d)" << std::endl;
	}

	~C() {
    	std::cout << "~C()" << std::endl;
	}
};


int main() {
	C c = 5.2;
	C* ptr = new C[3];

	delete ptr;
}
```

**Задача 6:** Какво ще се отпечата?

```c++
#include <iostream>

struct C {
	double d;

	C() {
		d = 3.14;
		std::cout << "C()" << std::endl;
	}

	C(double d) {
		this->d = d;
		std::cout << "C(double d)" << std::endl;
	}

	~C() {
		std::cout << "~C()" << std::endl;
	}
};

void f(C obj)
{
	std::cout << "f(C obj)" << std::endl;
}

int main() {
	f(5.12);
}
```

# Задачи:

**Задача 1:**

Създайте структура Car, която съдържа в себе си име на марка с произволна дължина, година на създаване, 
максимална скорост и масив с произволна дължина, пазещ колко километра са били пътуванията на колата (цяло число). 
Трябва да имплементирате:
 - Дефолтен конструктор
 - Конструктор с параметрите на колата
 - Деструктор (за да освободите динамичната памет, когато обектът умре)
 - Функция за записване на колата във файл
 - Функция, която прочита данни от файл
 - Функция, която връща колко общо са изминатите километри на автомобила
 - Функция, която връща големината на най-дългото пътуване

**Задача 2:**

Ще създадем проста система за работа със задачи. Всяка задача се състои от: 
 - Име, с произволна дължина.
 - Условие, с произволна дължина.
 - Цяло число, показващо колко точки носи задачата.
Също така всяка задача трябва да поддържа следната функционалност:
 - Да можем по всяко време да променяме условието на задачата.
 - Да можем по всяко време да променяме името на задачата.
 - Да можем по всяко време да променяме точките, които задачата носи.
Създайте структура, моделираща изпит, която поддържа константен брой (20) задачи и цяло число, 
показващо минималните точки, изискващи се за успешно вземане на изпита. 
Създайте също:
 - Функция за добавяне на задача
 - Функция writeToFile(const char* fileName), която записва контролното във файл.
 - Функция readFromFile(const char* fileName), която чете контролното от файл.
 - Функция changeMin(), която подава нов минимален успех за вземане на изпита. 
 - Функция getMax(), която извежда максималния брой точки за текущия изпит.

**Задача 3:**

Имплементирайте клас Set, който действа като множество от цели числа. Той трябва да предоставя следните член-функции:
 - bool addElement(int element) - ако елементът не присъства в множеството, го добавя и връща истина, 
в противен случай не прави нищо и връща лъжа
 - bool deleteElement(int element) - ако елементът присъства в множеството, го изтрива и връща истина, 
в противен случай не прави нищо и връща лъжа
 - void print() - принтира всички елементи от множеството
 - void serialize() - записва множеството в двоичен файл.
 - void setUnion(const Set& other) - извършва обединение между текущото множество и other като запазва резултатът в текущото множество
 - void setIntersection(const Set& other) - аналогично на горната функция, извършва сечение на множества
Също така вашата структура трябва да има конструктор Set(const char* fileName), където си зарежда съдържанието от двоичен файл.

//HINT: Когато ви свърши мястото в Set-а, ресайзвайте.

